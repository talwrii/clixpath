#!/usr/bin/python


from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

import argparse
import json
import os
import subprocess
import sys

import clixpath.clixpath

HERE = os.path.dirname(__file__)


def make_readme_text():
    parser = clixpath.clixpath.build_parser()
    help_text = parser.format_help()

    cheat_sheet = backticks(["bash", os.path.join(HERE, 'make-cheat-sheet.sh')])
    template_file = os.path.join(HERE, 'README.template')
    with open(template_file) as stream:
        return '<!-- This is generated by make-readme.py do not edit -->\n' + stream.read().format(
            usage=help_text,
            cheat_sheet=cheat_sheet
        )

def backticks(command, stdin=None, shell=False):
    stdin_arg = subprocess.PIPE if stdin is not None else None
    process = subprocess.Popen(command, stdout=subprocess.PIPE, stdin=stdin_arg, shell=shell, env=dict(os.environ, PYTHON=sys.executable))
    result, _ = process.communicate(stdin)
    if process.returncode != 0:
        raise Exception('{!r} returned non-zero return code {!r}'.format(command, process.returncode))
    result = result.decode('utf8')
    return result

def main():
    PARSER = argparse.ArgumentParser(description='Write readme.md')
    PARSER.add_argument('--stdout', action='store_true', help='Write to standard out rather than README.md')
    options = PARSER.parse_args()
    output = make_readme_text()
    if options.stdout:
        print(output, end='')
    else:
        with open('README.md', 'w') as out_stream:
            out_stream.write(output)

if __name__ == '__main__':
	main()
